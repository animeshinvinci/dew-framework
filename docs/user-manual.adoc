== 使用手册

TIP: 所有模块均为Maven结构

[source,xml]
----
<parent>
    <groupId>com.tairanchina.csp.dew</groupId>
    <artifactId>parent</artifactId>
    <version>1.0.0-SNAPSHOT</version>
</parent>
...
<dependencies>
    <dependency>
        <groupId>com.tairanchina.csp.dew</groupId>
        <artifactId><模块名></artifactId>
    </dependency>
</dependencies>
...
----

TIP: `parent` 中已包含各模块的版本，引用模块依赖时可省略版本号

NOTE: 由于本框架并没有修改Spring Boot/Cloud的功能，所以部分功能会提供使用原生写法和Dew写法两个版本进行对照

=== 构建一个最基本的Spring Boot工程

==== 原生版本

[source,xml]
.引入依赖
----
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>1.5.2.RELEASE</version>
</parent>
…
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>Dalston.SR1</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter</artifactId>
    </dependency>
</dependencies>
…
----

[source,java]
.添加启动类
----
@SpringBootApplication
@EnableAutoConfiguration()
public class BoneExampleApplication {
 public static void main(String[] args) {
     new SpringApplicationBuilder(BoneExampleApplication.class).run(args);
 }
}
----

==== Dew版本

[source,xml]
.引入依赖
----
<parent>
    <groupId>com.tairanchina.csp.dew</groupId>
    <artifactId>parent</artifactId>
    <version>1.0.0-SNAPSHOT</version>
</parent>
…
<dependencies>
    <dependency>
        <groupId>com.tairanchina.csp.dew</groupId>
        <artifactId>boot-core</artifactId>
    </dependency>
</dependencies>
…
----

TIP: Dew版本的 `parent` 模块已经加入Spring Boot dependencyManagement，依赖了`spring-boot-starter-actuator`

[source,java]
.添加启动类
----
public class BoneExampleApplication extends DewBootApplication {
    public static void main(String[] args) {
        new SpringApplicationBuilder(BoneExampleApplication.class).run(args);
    }
 }
----

[TIP]
.DewBootApplication使用如下注解
====
* @SpringBootApplication
* @EnableTransactionManagement
* @EnableAutoConfiguration(exclude = {FreeMarkerAutoConfiguration.class, GsonAutoConfiguration.class, WebSocketAutoConfiguration.class})
* @ComponentScan(basePackageClasses = {Dew.class})
* @EnableAspectJAutoProxy(proxyTargetClass = true)
====

NOTE: 由于Maven的 `parent` 引用是固定的，为节省篇幅后文只写依赖包

=== 启用Web服务

==== 原生版本

[source,xml]
.引入依赖
----
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
</dependencies>
…
----

[source,java]
.添加启动类
----
@SpringBootApplication
@EnableAutoConfiguration()
public class WebExampleApplication {
    public static void main(String[] args) {
        new SpringApplicationBuilder(WebExampleApplication.class).run(args);
    }
}
----

[source,java]
.添加Controller
----
@RestController
public class ExampleController {
   @GetMapping("/example")
   public String example() {
       return "enjoy!";
   }
}
----

==== Dew版本

[source,xml]
.引入依赖
----
<dependencies>
    <dependency>
        <groupId>com.tairanchina.csp.dew</groupId>
        <artifactId>boot-core</artifactId>
        <version>${dew.version}</version>
    </dependency>
    <!-- 引入web依赖 -->
        <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
</dependencies>
…
----

[source,java]
.添加启动类
----
public class WebExampleApplication extends DewBootApplication {
   public static void main(String[] args) {
       new SpringApplicationBuilder(WebExampleApplication.class).run(args);
   }
}
----

* 添加Controller (同原生版本)

=== 使用Swagger API文档

==== 原生版本

[source,xml]
.引入依赖 (在 `启用Web服务` 的基础上增加)
----
<dependencies>
    <dependency>
        <groupId>io.springfox</groupId>
        <artifactId>springfox-swagger2</artifactId>
        <version>${swagger.version}</version>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>io.springfox</groupId>
        <artifactId>springfox-swagger-ui</artifactId>
        <version>${swagger.version}</version>
        <optional>true</optional>
    </dependency>
</dependencies>
…
----

* 添加 Docket Bean

TIP: 详见 https://github.com/swagger-api/swagger-samples/blob/master/java/java-spring-boot/src/main/java/io/swagger/sample/Application.java[https://github.com/swagger-api/swagger-samples/blob/master/java/java-spring-boot/src/main/java/io/swagger/sample/Application.java]

==== Dew版本

* 引入依赖 (同原生版本)

[source,yml]
.增加配置
----
dew:
    basic:
    name: # 文档名称
    version: # 文档版本
    desc: # 文档描述
    webSite: # 文档官网
    doc:
        basePackage:  # 要扫描的包路径
----

=== 使用离线API文档

实现Html及PDF版本的离线API文档，效果如下：

image:http://swagger2markup.github.io/swagger2markup/1.3.1/images/Swagger2Markup.PNG[]

==== 原生版本

NOTE: 未提供此功能，实现复杂，见：https://github.com/Swagger2Markup/spring-swagger2markup-demo

==== Dew版本

TIP: 确保引入了上文的 `Swagger` 依赖

[source,java]
.建立如下测试类，WebExampleApplication修改成对应的启动类
----
@RunWith(SpringRunner.class)
@SpringBootApplication
@SpringBootTest(classes = {Dew.class, WebExampleApplication.class}, webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT)
public class DocTest {

    @Test
    public void empty(){}

}
----

[source,shell]
.执行如下命令
----
mvn -Dtest=DocTest clean test -P doc
----

* 查看工程目录，多了一个 `api-docs` 的目录，包含了 `index.html` 和 `index.pdf` 两个离线文档

[TIP]
.定制化文档
====
创建或编辑 `api-docs/asciidoc/index.adoc` 加入个性化内容，此为 `asciidoc` 格式，使用见： http://asciidoctor.org/docs/asciidoc-writers-guide/
====

=== 启用JDBC功能(JdbcTemplate)

==== 原生版本

[source,xml]
.引入依赖
----
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-jdbc</artifactId>
    </dependency>
    <!-- 对应的数据库JDBC驱动 -->
</dependencies>
----

[source,yml]
.增加配置
----
spring:
    datasource:
    driver-class-name: # 驱动名
    url: # 驱动url
----

[source,java]
.使用JDBC
----
@Autowired
JdbcTemplate jdbcTemplate;

public void test() throws Exception {
    jdbcTemplate.execute("DROP TABLE customers IF EXISTS");
    jdbcTemplate.execute("CREATE TABLE customers(" +
            "id SERIAL, first_name VARCHAR(255), last_name VARCHAR(255))");

    List<Object[]> splitUpNames = Arrays.asList("John Woo", "Jeff Dean", "Josh Bloch", "Josh Long").stream()
            .map(name -> name.split(" "))
            .collect(Collectors.toList());

    jdbcTemplate.batchUpdate("INSERT INTO customers(first_name, last_name) VALUES (?,?)", splitUpNames);

    jdbcTemplate.query(
            "SELECT id, first_name, last_name FROM customers WHERE first_name = ?", new Object[] { "Josh" },
            (rs, rowNum) -> new Customer(rs.getLong("id"), rs.getString("first_name"), rs.getString("last_name"))
    ).forEach(customer -> log.info(customer.toString()));
}
....
----

TIP: `JdbcTemplate` 知识见 https://spring.io/guides/gs/relational-data-access/[https://spring.io/guides/gs/relational-data-access/]

==== Dew版本

[source,xml]
.引入依赖
----
<dependencies>
    <dependency>
        <groupId>com.tairanchina.csp.dew</groupId>
        <artifactId>boot-core</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-jdbc</artifactId>
    </dependency>
    <!-- 对应的数据库JDBC驱动 -->
</dependencies>
----

* 增加配置 (同原生版本)

[source,java]
.使用JDBC
----
// ddl
Dew.ds().jdbc().execute("CREATE TABLE example_entity\n" +
        "(\n" +
        "id int primary key auto_increment,\n" +
        "field_a varchar(255)\n" +
        ")");
// insert
ExampleEntity entity = new ExampleEntity();
entity.setFieldA("测试A");
Object id = Dew.ds().insert(entity);
// get
logger.info(">>>> "+Dew.ds().getById(id, ExampleEntity.class).getFieldA());
----

==== Dew对 `JdbcTemplate` 做扩展

*支持实体与SQL的映射*

* 可选的注解:
** `Entity`: 表示此类可映射为数据库表
** `PkColumn`: 主键标识 存在此注解的实体可以使用 `xxxById` 操作
** `CodeColumn`: 业务主键 在工程中很多对象的主键不依赖于数据库主键而会使用code（如uuid表示）作为业务主键，
** 保存（insert）时如果存在业务主键，且`value==null &amp;&amp; uuid=true`，则会自动附加上uuid
** 存在此注解的实体可以使用 `xxxByCode` 操作
** `CreateUserColumn`: 创建人，保存（insert）时自动附加当前操作人`code`（需要与获取操作人动作同一线程）
** `CreateTimeColumn`: 创建时间，保存（insert）时自动附加当前时间
** `UpdateUserColumn`：更新人，保存（insert）更新（updateById/updateByCode）时自动附加当前操作人`code`（需要与获取操作人动作同一线程）
** `UpdateTimeColumn`: 更新时间，保存（insert）更新（updateById/updateByCode）时自动附加当前时间
** `EnabledColumn`: 状态，启用或禁用 存在此注解的实体可以使用 `enableByxx` `disableByxx` `xxEnabled` `xxDisabled` 操作
** `Column`: 普通字段

IMPORTANT: 只有存在`Entity`注解的类才会被解析，只有存在`XXColumn`的字段才会被映射

TIP: 为方便操作，框架提供了`PkEntity` `SafeEntity` `StatusEntity` `SafeStatusEntity` 四个预制的父类

* 支持常用操作

** *增加* `Dew.ds().insert(Object entity) / Dew.ds().insert(Iterable<?> entities)`
** *更新* `Dew.ds().updateById(Object id, Object entity) / Dew.ds().updateByCode(String code, Object entity)`
** *获取单条* `Dew.ds().getById(Object id, Class<E> entityClazz) / Dew.ds().getByCode(String code, Class<E> entityClazz)`
** *获取多条* `Dew.ds().findAll(Class<E> entityClazz) / Dew.ds().findAll(LinkedHashMap<String, Boolean> orderDesc, Class<E> entityClazz) / Dew.ds().findEnabled(…) / Dew.ds().findDisabled(…)`
** *获取分页* `Dew.ds().paging(long pageNumber, int pageSize, LinkedHashMap<String, Boolean> orderDesc, Class<E> entityClazz) / Dew.ds().pagingEnabled(…) / Dew.ds().pagingDisabled(…)`
** *计数* `Dew.ds().countAll(Class<?> entityClazz) / Dew.ds().countEnabled(Class<?> entityClazz) / Dew.ds().countDisabled(Class<?> entityClazz)`
** *启用* `Dew.ds().enableById(Object id, Class<?> entityClazz) / Dew.ds().enableByCode(String code, Class<?> entityClazz)`
** *禁用* `Dew.ds().disableById(Object id, Class<?> entityClazz) / Dew.ds().disableByCode(String code, Class<?> entityClazz)`
** *是否存在* `Dew.ds().existById(Object id, Class<?> entityClazz) / Dew.ds().existByCode(String code, Class<?> entityClazz)`
** *物理删除* `Dew.ds().deleteById(Object id, Class<?> entityClazz) / Dew.ds().deleteByCode(String code, Class<?> entityClazz)`

TIP: 您可以使用：`Dew.ds().jdbc()` 获取 `JdbcTemplate` 原生API

===== 支持@Select注解

* 格式

[source]
----
@Select(value = "<SQL，使用#{参数占位名}>", entityClass = <返回的实体，为空时以Map封装>)
<返回类型，可为单个对象/List/Page> <方法名，java规范即可>(<行参修饰符，@Param(<参数占位名>)或@ModelParam> <行参>);
----

TIP: 方法参数Bean类型需使用 `@ModelParam` ，参数作为SQL参数需使用 `@Param()` 并指定与#{}相匹配的名称。
`@Select` 中entityClass用于指定返回类型。

* 使用示例

添加扫描配置： `dew.dao.base-package: xxx`

[source,java]
.返回全量数据
----
@Select(value = "select * from t_test_crud_s_entity where field_a= #{ fieldA }", entityClass = CRUDSTestEntity.class)
List<CRUDSTestEntity> queryByField(@Param("fieldA") String fieldA);
----

[source,java]
.返回分页数据
----
@Select(value = "select * from t_test_crud_s_entity where field_a= #{ fieldA }", entityClass = CRUDSTestEntity.class)
Page<CRUDSTestEntity> queryByCustomPaging(@ModelParam CRUDSTestEntity model, @Param("pageNumber") Long pageNumber, @Param("pageSize") Integer pageSize);
----

[source,java]
.返回Bean类型数据
----
@Select(value = "select * from t_test_crud_s_entity where id= #{id}", entityClass = CRUDSTestEntity.class)
CRUDSTestEntity getById(@Param("id") Object id);
----

[source,java]
.返回Map类型数据
----
@Select(value = "select * from t_test_crud_s_entity where id= #{id}")
Map<String,Object> getMapById(@Param("id") Object id);
----

* 限定

. `@Select` 只能用于接口
. `@Select` 暂不支持DSL SQL，比如（HQL）
. `@ModelParam` 参数不支持 `null` 查询
. `where` 语句之后请添加1=1，即：`where 1=1`


=== 多数据源支持

==== 原生版本

[source,properties]
.配置数据源
----
# 主数据源
spring.datasource.url=…
spring.datasource.username=…
spring.datasource.password=…
spring.datasource.driver-class-name=…
spring.datasource.tomcat.max-idle=…
…
# 其它数据源
spring.datasource.secondary.url=…
spring.datasource.secondary.username=…
spring.datasource.secondary.password=…
spring.datasource.secondary.driver-class-name=…
spring.datasource.secondary.tomcat.max-idle=…
…
----

[source,java]
.添加DataSource
----
@Bean
@Primary 
@ConfigurationProperties(prefix="spring.datasource")
public DataSource primaryDataSource() {
    return DataSourceBuilder.create().build();
}
  
@Bean
@ConfigurationProperties(prefix="spring.datasource.secondary")  
public DataSource secondaryDataSource() {  
    return DataSourceBuilder.create().build();  
}  
----

[source,java]
.添加JdbcTemplate
----
@Bean
@Primary
public JdbcTemplate primaryJdbcTemplate(@Qualifier("primaryDataSource")DataSource dataSource){
    return new JdbcTemplate(dataSource);
}

@Bean
public JdbcTemplate secondaryJdbcTemplate(@Qualifier("secondaryDataSource")DataSource dataSource){
    return new JdbcTemplate(dataSource);
}
---- 

[source,java]
.启用事务
----
@EnableTransactionManagement
----

[source,java]
.添加事务
----
@Bean
@Primary
public PlatformTransactionManager primaryTransactionManager(@Qualifier("primaryDataSource") DataSource dataSource) {
    return new DataSourceTransactionManager(dataSource);
}

@Bean
public PlatformTransactionManager secondaryTransactionManager(@Qualifier("secondaryDataSource") DataSource dataSource) {
    return new DataSourceTransactionManager(dataSource);
}
----

[source,java]
.使用
----
@Autowired
private JdbcTemplate jdbcTemplate;

@Autowired
@Qualifier("secondaryJdbcTemplate")
private JdbcTemplate secondaryJdbcTemplate;

@Transactional
public long insert(Object entity) {
    // DoSomething
    jdbcTemplate.xxx;
}

@Transactional(secondaryTransactionManager)
public long insert(Object entity) {
    // DoSomething
    secondaryJdbcTemplate.xxx;
}
----

==== Dew版本

[source,properties]
.配置数据源
----
# 主数据源
spring.datasource.url=…
spring.datasource.username=…
spring.datasource.password=…
spring.datasource.driver-class-name=…
spring.datasource.tomcat.max-idle=…
…
# 其它数据源1
spring.datasource.multi-datasources.other1.url=…
spring.datasource.multi-datasources.other1.username=…
spring.datasource.multi-datasources.other1.password=…
spring.datasource.multi-datasources.other1.driver-class-name=…
spring.datasource.multi-datasources.other1.max-idle=…
# 其它数据源2
spring.datasource.multi-datasources.other2.url=…
…
----

IMPORTANT: 其它数据源务必配置在 `spring.datasource.multi-datasources` 下，格式是 `spring.datasource.multi-datasources.<DS Name>.<属性名>=<属性值>`

IMPORTANT: 主数据源连接池要加上 `tomcat` 或其它类型，其它数据源与 `url` 、 `username` 同级即可。

[source,java]
.使用
----
// Dew常规方式

Dew.ds().xxx // 使用主数据源
Dew.ds("other1").xxx // 使用DS Name为`other1`的数据源

// 泛型DAO (详见 `服务脚手架` 章节)

@Repository
public class CRUDSTestDao implements DewDao<CRUDSTestEntity> {
    @Override
    public String ds() {
        return "other1"; // 使用DS Name为`other1`的数据源，此方法不重载时表示使用主数据源
    }
}

// 手工注入（同原生版本）

@Autowired
private JdbcTemplate jdbcTemplate;

@Autowired
@Qualifier("other1JdbcTemplate")
private JdbcTemplate secondaryJdbcTemplate;

@Transactional
public long insert(Object entity) {
    // DoSomething
    jdbcTemplate.xxx;
}

@Transactional(other1TransactionManager)
public long insert(Object entity) {
    // DoSomething
    secondaryJdbcTemplate.xxx;
}
----

IMPORTANT: `JdbcTemplate` Bean名称规则：主数据源= `jdbcTemplate` ，其它数据源= `<DS Name>JdbcTemplate`

IMPORTANT: `TransactionManager` Bean名称规则：主数据源= `transactionManager` ，其它数据源= `<DS Name>TransactionManager`


====
 以下功能原生版本支持比较繁琐或无对应实现，后文只描述Dew框架实现
====

=== 启用集群功能

Dew的集群支持 `分布式缓存` `分布式Map` `分布式锁` `MQ` ，并且做了接口抽象以适配不同的实现，目前支持 `Redis` 、 `Hazelcast` 、 `Rabbit` ，对 `Ignite` 的适配正在进行中。

[source,xml]
.引入依赖
----
<dependencies>
    <dependency>
    <groupId>com.tairanchina.csp.dew</groupId>
    <artifactId>boot-core</artifactId>
</dependency>
<!--引入集群依赖，可选redis/hazelcast/rabbit-->
<dependency>
    <groupId>com.tairanchina.csp.dew</groupId>
    <artifactId>cluster-spi-redis</artifactId>
</dependency>
<dependency>
    <groupId>com.tairanchina.csp.dew</groupId>
    <artifactId>cluster-spi-hazelcast</artifactId>
</dependency>
<dependency>
    <groupId>com.tairanchina.csp.dew</groupId>
    <artifactId>cluster-spi-rabbit</artifactId>
</dependency>
----

[source,yml]
.增加配置
----
spring:
    redis:
        host: # redis主机
        port: # redis端口
        database: # redis数据库
        password: # redis密码
        pool:
          max-active:
          max-wait:
          max-idle:
          min-idle:
    rabbitmq:
      host: # rabbit主机
      port: # rabbit端口
      username: # rabbit用户名
      password: # rabbit密码
      virtual-host: # rabbit VH
    hazelcast:
    addresses: [] # hazelcast地址，端口可选

dew:
    cluster:
    cache: redis
    dist: hazelcast # 可选 redis/hazelcast
    mq: hazelcast # 可选 redis/hazelcast/rabbit
----

[source,java]
.使用集群功能
----
// 缓存示例，类似redis语法，支持string、list、hash
Dew.cluster.cache.flushdb();
Dew.cluster.cache.del("n_test");
assert !Dew.cluster.cache.exists("n_test");
Dew.cluster.cache.set("n_test", "{&quot;name&quot;:&quot;jzy&quot;}", 1);
assert Dew.cluster.cache.exists("n_test");
assert "jzy".equals($.json.toJson(Dew.cluster.cache.get("n_test")).get("name").asText());
Thread.sleep(1000);
assert !Dew.cluster.cache.exists("n_test");
assert null == Dew.cluster.cache.get("n_test");

// 分布式Map，支撑常用Map操作
ClusterDistMap<TestMapObj> mapObj = Dew.cluster.dist.map("test_obj_map", TestMapObj.class);
mapObj.clear();
TestMapObj obj = new TestMapObj();
obj.a = "测试";
mapObj.put("test", obj);
assert "测试".equals(mapObj.get("test").a);

// 分布式锁
ClusterDistLock lock = Dew.cluster.dist.lock("test_lock");
lock.delete();
lock.lock();
assert !lock.tryLock();

// MQ:发布-订阅模型
Dew.cluster.mq.subscribe("test_pub_sub", message ->
logger.info("pub_sub>>" + message));
Thread.sleep(1000);
Dew.cluster.mq.publish("test_pub_sub", "msgA");
Dew.cluster.mq.publish("test_pub_sub", "msgB");

// MQ:请求-响应模型
Dew.cluster.mq.response("test_rep_resp", message ->
logger.info("req_resp>>" + message));
Dew.cluster.mq.request("test_rep_resp", "msg1");
Dew.cluster.mq.request("test_rep_resp", "msg2");
----

[IMPORTANT]
.SPI选型
====
. Redis: 多用于Cache，可做为轻量MQ，可用于要求不高的Lock(Redis锁存在不安全隐患)及Map
. Hazelcast: 对Lock及Map支持得很好，可做为轻量MQ
. Rabbit: 仅做MQ用，支持持久化，支持仅在收到消息并且处理完成后才Acknowledge
====

=== 服务脚手架

一般的，我们对实体对象的操作可以有 `增C删D改U查R` 外加`状态变更S`，`服务脚手架`从`DAO`到`Service`再到`Controller`实现了上述操作。


* CRUController: 支持增改查操作
* CRUDController: 支持增删改查操作
* CRUSController: 支持增改查状态变更操作
* CRUDSController: 支持增删改查状态变更操作
* CRUVOController: 支持增改查操作（带VO-Entity转换）
* CRUSVOController: 支持增删改查操作（带VO-Entity转换）
* CRUDVOController: 支持增改查状态变更操作（带VO-Entity转换）
* CRUDSVOController: 支持增删改查状态变更操作（带VO-Entity转换）
* CRUService: 支持增改查操作
* CRUDService: 支持增删改查操作
* CRUSService: 支持增改查状态变更操作
* CRUDSService: 支持增删改查状态变更操作
* DewDao: 支持增删改查状态变更操作

TIP: 详见API文档

=== CORS支持

默认支持，在`启用Web服务`章节的基础上加上如下配置实现定制：

[source,yml]
----
dew:
  security:
    cors:
      allow-origin: # 允许来源，默认 *
      allow-methods: # 允许方法，默认 POST,GET,OPTIONS,PUT,DELETE,HEAD
      allow-headers: # 允许头信息 x-requested-with,content-type
----

=== 统一响应格式

Dew支持两种格式：

* 协议无关：`Resp<E>` 响应，对于`HTTP`统一返回`200`状态，使用`code`表示实际状态，`Resp`对象包含:

 code 响应编码，与http状态码类似，200表示成功
 message 响应附加消息，多有于错误描述
 body 响应正文

TIP: `Resp`类提供了常用操作：详见 https://gudaoxuri.github.io/dew-common/#true-resp[https://gudaoxuri.github.io/dew-common/#true-resp]

* 重用`HTTP Status Code`: 在无错误时直接返回内容，发生错误时返回 `{"error":{"code":"实际错误码","message":"错误信息"}}`

TIP: 如果启用了字段检查（ `@RequestBody @Valid ...` ），在检查不通过时会上述两种格式的 `message` 内容返回Json格式的错误详细（ `Detail:` 标识之后的内容），格式为：
     `[{"field":"<字段名>","reason":"<原因，如NotNull,Min>","msg":"<错误描述>"}]`

启用统一响应格式支持：

[source,yml]
.配置
----
dew:
    basic:
        format:
            use-unity-error: true # 默认false
            reuse-http-state: # true:重用http状态码，false:使用协议无关格式
----

[source,java]
.相关代码
----
// 使用协议无关格式
public Resp<String> test(){
    return Resp.success("enjoy!");
    // or return Resp.notFound("…")/conflict("…")/badRequest("…")/…
}

// 重用http状态码
// 与协议无关格式区别在于：
// 1. throws 对应的异常
// 2. 使用Dew.e(<code>,<Exception Instance>)来抛出异常
public String test() throws IOException{
    return "enjoy!";
    // or throw Dew.e("A000", new IOException("io error"));
    // or throw Dew.e("A000", new IOException("io error"),StandardCode.UNAUTHORIZED); // 自定义http异常401
}
----

=== 认证缓存

[quote,]
____
Dew内核不支持鉴权处理（Auth组件功能），但它支持`认证缓存`，即支持将鉴权系统生成的登录信息缓存到业务系统中方便即时调用。
____

[source,yml]
.配置认证缓存
----
dew:
    security:
        token-flag: # token key的名称
        token-in-header: # token key是否在http header中，为false是会从url query中获取
        token-hash: # token 值是否做hash（MD5）处理
----

[source,java]
.使用
----
// 添加登录信息，optInfo封装自鉴权系统过来的登录信息
// 一般在登录认证后操作
Dew.Auth.setOptInfo(OptInfo optInfo);
// 获取登录信息，要求在http请求加上token信息
Dew.context().optInfo();
// 删除登录信息
// 一般在注销登录后操作
Dew.Auth.removeOptInfo();

// 登录信息
public class OptInfo {
    // Token
    String token;
    // 账号编码
    String accountCode;
    // 登录ID
    String loginId;
    // 手机号
    String mobile;
    // 邮箱
    String email;
    // 姓名
    String name;
    // 角色列表
    List<RoleInfo> roles;
    // 最后一次登录时间
    Date lastLoginTime;
    // 扩展信息(Json格式)
    String ext;
    // 角色信息
    public static class RoleInfo {
        // 角色编码
        String code;
        // 角色显示名称
        String name;
        // 租户编码
        String tenantCode;
    }
}
----

=== 服务调用开发期优化

在Spring Cloud体系下，服务调用需要启动`Eureka`服务（对于Dew中的`Regstry`组件），这对开发阶段并不友好：

. 开发期间会不断启停服务，`Eureka` 保护机制会影响服务注册（当然这是可以关闭的）
. 多人协作时可能会出现调用到他人服务的情况（同一服务多个实例）
. 需要启动 `Eureka` 服务，多了一个依赖

为解决上述问题，Dew框架做了相应的优化，
在服务调用时使用 `Dew.EB.post/get/put/delete/options/head` 方法，Dew会根据传入的 `URL` 判断，
如果是 `IPv4` 则直接调用服务，否则使用Spring Cloud的 `RestTemplate` 调用。
所以您只需要把服务url做成配置，开发时使用 `ip` ，测试/生产时使用 `service-id` 。

=== Dubbo协同

[source,xml]
.引入依赖
----
<dependency>
    <groupId>io.dubbo.springboot</groupId>
    <artifactId>spring-boot-starter-dubbo</artifactId>
    <version>1.0.0</version>
    <exclusions>
        <exclusion>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </exclusion>
        <exclusion>
            <groupId>log4j</groupId>
            <artifactId>log4j</artifactId>
        </exclusion>
        <exclusion>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
        </exclusion>
        <exclusion>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-classic</artifactId>
        </exclusion>
    </exclusions>
</dependency>
----

* 配置与使用

Dubbo官方发行版本无法处理存在声明式事务的服务，简单的解决方案是：

[source,java]
.添加com.alibaba.dubbo.config.annotation.Service到工程
----
package com.alibaba.dubbo.config.annotation;

import java.lang.annotation.*;

/**
 * 添加@Inherited，修正带声明式事务的服务提供问题
 */
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE})
@Inherited
public @interface Service {

    Class<?> interfaceClass() default void.class;

    String interfaceName() default "";

    String version() default "";

    String group() default "";

    String path() default "";

    boolean export() default false;

    String token() default "";

    boolean deprecated() default false;

    boolean dynamic() default false;

    String accesslog() default "";

    int executes() default 0;

    boolean register() default false;

    int weight() default 0;

    String document() default "";

    int delay() default 0;

    String local() default "";

    String stub() default "";

    String cluster() default "";

    String proxy() default "";

    int connections() default 0;

    int callbacks() default 0;

    String onconnect() default "";

    String ondisconnect() default "";

    String owner() default "";

    String layer() default "";

    int retries() default 0;

    String loadbalance() default "";

    boolean async() default false;

    int actives() default 0;

    boolean sent() default false;

    String mock() default "";

    String validation() default "";

    int timeout() default 0;

    String cache() default "";

    String[] filter() default {};

    String[] listener() default {};

    String[] parameters() default {};

    String application() default "";

    String module() default "";

    String provider() default "";

    String[] protocol() default {};

    String monitor() default "";

    String[] registry() default {};

}
----

[source,java]
.在带声明式事务的类显示声明 `interfaceName`
----
@Service(version = "",interfaceName = "")
----

TIP: 详见：`dubbo-example`

=== 使用Thrift文档

. 扩展TTransport支持从注册中心获取服务列表并根据既定策略进行负载，详见TLoadBalancerClient类，利用Netflix
. 服务端添加Metrics支持，统计各服务响应时间及各方法调用次数
. 封装TServiceClient支持超时熔断保护利用Hystrix

==== 生成API
安装Thrift [https://thrift.apache.org/]

[source,xml]
.引入依赖
----
<dependency>
    <groupId>org.apache.thrift</groupId>
    <artifactId>libthrift</artifactId>
    <version>0.10.0</version>
</dependency>
----

.编辑Thrift文件
教程[http://www.jianshu.com/p/0f4113d6ec4b]

[source,shell]
.执行
----
thrift --gen <language> <Thrift filename>
----
==== Spring Cloud工程使用

* 在启动类，添加`@EnabledThriftDiscovery`

[source,xml]
.引入依赖
----
<dependency>
    <groupId>com.tairanchina.csp.dew</groupId>
    <artifactId>boot-thrift-start</artifactId>
    <version>1.0.0-SNAPSHOT</version>
<dependency>
----

===== Service

[source,java]
.实现Iface接口
----
@ThriftService(value = "/url")
public class CalculatorController implements TCalculatorService.Iface {

}
----
[source,yaml]
.配置
----
thrift:
  client:
      maxThread: 10
----

===== Client

[source,java]
.实现Iface接口
----
@ThriftClient(serviceId = "thrift-service-example", path = "/url")
TCalculatorService.Client tcalculatorClient;
----

[source,yaml]
.配置
----
thrift:
    service:
          connectTimeout: 2000
          readTimeout: 50000
          maxRetries: 3
          endpoint:
----

TIP: 详见：`thrift-service-example`