== 最佳实践（TBD）

=== JDBC框架的选择

主流JDBC框架有Hibernate、MyBatis、Spring JDBC Template、Ebean、DBUtils等，Dew基于Spring Boot，所以对于这些框架都提供了很好的兼容。那么如何选择呢？

* 先说Hibernate，如果你的数据表结构与对象模型基本吻合，那么使用JPA会带来很大的便捷，推荐Hibernate
* 如果你的数据表结构与对象模型严重不吻合或是你希望对SQL有更多主动权（SQL优化、复杂查询等），那JPA就没什么优势了，这时：
** 如果你追求极简、不需要ORMPPING，那么DBUtils会是最佳选择
** 如果你喜欢敏捷开发，推崇充血模型，那么尝试一下Ebean吧，与Play!结合最合适不过
** 如果你既要有一定的ORMPPING能力，又希望自己写SQL，那么MyBatis会是不错的选择
** 如果你使用了Spring，希望框架简单些，可以接受自己写ORMPPING，未来无切换关系型数据库的计划，那么Spring JDBC Template将是个很好的选择

上述是几个主流JDBC框架的使用场景分析，Dew默认的是哪个呢？Dew默认的是基于Spring JDBC Template的封装，其理由如下：

1. Dew做为内部框架，需要能从容地处理公司规划的领域模型结构，但这一数据模型无法与对象模型对应，所以JPA的优势无法体现
1. Dew希望尽可能保持“轻巧”，结构简单、容易上手，Hibernate相对而言过重了

基于两个原因Hibernate并不适合使用，又因为：

1. 在数据库设计上一般会存在业务主键、是否启用状态等字段，经常需要针对这些字段查询、修改
1. 在数据库设计上一般会存在创建人/时间、更新人/时间等常规字段，在创建、更新对象时需要自动赋值
1. 希望能有自动化的ORMPPING功能
1. 要求能很好的支持多数据源操作

基于这三个原因MyBatis、Ebean、DBUtils及Spring JDBC Template都无法满足要求。

所以为适应这一场景需求，Dew基于Spring JDBC Template做了扩展以支持上述功能。


=== 缓存处理
Spring Cache提供了很好的注解式缓存，但默认没有超时，需要根据使用的缓存容器特殊配置，e.g.

[source,java]
.Redis缓存过期时间设置
----
@Bean
RedisCacheManager cacheManager() {
    final RedisCacheManager redisCacheManager = new RedisCacheManager(redisTemplate);
    redisCacheManager.setUsePrefix(true);
    redisCacheManager.setDefaultExpiration(<过期秒数>);
    return redisCacheManager;
}
----

=== 断路保护

使用断路保护可有效果的防止系统雪崩，Spring Cloud对Hystrix做了封装，详见：http://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#_circuit_breaker_hystrix_clients
需要说明的是Hystrix使用新线程执行代码，导致Threadlocal数据能同步，使用时需要将用到的数据做为参数传入，如果需要使用Dew框架的上下文（请求链路/用户等获取）需要先传入再设值，e.g.

[source,java]
.Context处理
----
@HystrixCommand(...)
public <return> someMethod(..., DewContext context) {
    DewContext.setContext(context);
    ....
}
----

=== 单元测试

良好的单元测试可以保证代码的高质量，单测的重要原则是内聚、无依赖，好的单测应该是"函数化"的——结果的变化只与传入参数有关。
但实际上我们会的代码往往会与数据库、缓存、MQ等外部工具交互，这会使单测的结果不可控，通常的解决方案是使用Mock，但这无行中引入了单测撰写的成本，
所以这里推荐使用"内嵌式"工具解决，数据库使用 `H2` ，Redis使用 `embedded redis` ，由于 `Dew` 集群的 `Cache` `Map` `Lock` `MQ` 都支持 `Redis` 实现，所以可以做到对主流操作的全覆盖。

[source,xml]
.配置示例
----
# maven
<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>com.github.kstyrc</groupId>
    <artifactId>embedded-redis</artifactId>
    <scope>test</scope>
</dependency>

# config
spring:
  redis:
    host: localhost
    port: 6379
  datasource:
    driver-class-name: org.h2.Driver
    url: jdbc:h2:mem:test

----

[source,java]
.使用示例
----
// embedded redis 需要初始化
private RedisServer redisServer;

@Before
public void init() throws IOException {
    redisServer = new RedisServer();
    if (!redisServer.isActive()) {
        redisServer.start();
    }
}

@After
public void destroy() {
    if (redisServer.isActive()) {
        redisServer.stop();
    }
}
----


    




